package section3;import javax.persistence.*;public class Main3 {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory("test");        EntityManager em = emf.createEntityManager();        EntityTransaction tx = em.getTransaction();        tx.begin();        try {            //test1(em); //3-1. 영속성 컨텍스트(1)            //test2(em); //3-2. 영속성 컨텍스트(2)            //test3(em); //3-3. 플러시            tx.commit();        } catch (Exception e) {            tx.rollback();        } finally {            em.close();        }        emf.close();    }    //3-1. 영속성 컨텍스트(1)    public static void test1(EntityManager em){        //[1] 비영속            Member3 member1 = new Member3();            member1.setId(20L);            member1.setName("20L");        //member객체 를 최초로 생성하고 입력까지만 해둠 = 비영속 상태        //[2] 영속            //아래 코드에 의해 member는 영속상태가 됨            System.out.println("=== BEFORE ===");            em.persist(member1);            //영속상태로 변하긴하지만, db에 저장이 되는것은 아님!            //만약 이 단계에서 db에저장이되려면 sql의 전달이 필요한데, 이 코드 앞뒤에 sysout을 찍어서 sql이 언제 전달되는지 확인해볼 수 있음            System.out.println("=== AFTER ===");            //sout after가 끝날때까지 sql은 실행되지 않음 = persist에 의해 db에 저장되는것이 아님        //[3]준영속            Member3 member2 = new Member3();            member2.setId(30L);            member2.setName("30L");            em.persist(member2);            em.detach(member2);        //[4]삭제 : 요건 sql이 생성되네?            Member3 member3 = new Member3();            member3.setId(40L);            member3.setName("40L");            em.persist(member3);            em.remove(member3);    }    //3-2. 영속성 컨텍스트(2)    public static void test2(EntityManager em){        //[1] 1차캐시 확인해보기(1)        Member3 member0 = new Member3();        member0.setId(123L);        member0.setName("123L");        System.out.println("=== before ===");        em.persist(member0);        System.out.println("=== after ===");        Member3 findMember = em.find(Member3.class, 123L);        System.out.println("=== find ===");        System.out.println(findMember.getId());        System.out.println(findMember.getName());        System.out.println("=== ==== ===");        //[2] 1차캐시 확인해보기(2) : 이제 저장된 정보로 find를 2번 실행해볼게(데이터베이스에서 조회)        Member3 findMember1 = em.find(Member3.class, 123L); //처음에 불러올땐 sql을 불러야하고        Member3 findMember2 = em.find(Member3.class, 123L); //같은 내용을 두번째 불러올땐(트랜잭션 실행 전) sql을 불러오면 안됨        //[3] 영속 엔티티의 동일성 보장        System.out.println("영속엔티티의 동일성 보장 : " + (findMember1==findMember2));        //[4] 트랜잭션을 지원하는 쓰기지연        Member3 member111 = new Member3(111L, "111");        Member3 member222 = new Member3(222L, "222");        em.persist(member111);        em.persist(member222);        //위 단계까진 db에 전달을 하지 않으므로 sql이 발생하지 않음        System.out.println("==== persist 이후 트랜잭션 커밋단계에서 db에 전달하기위한 sql이 생성됨 ===");        //[5]변경감지        Member3 member = em.find(Member3.class, 111l);        member.setName("update");        //em.persist(member); //요걸 써야할거같지만 쓰면안됨!        System.out.println("==== ===== ====");    }    // //3-3.플러시    public static void test3(EntityManager em){        Member3 member = new Member3(333L, "333");        em.persist(member);        System.out.println("==== persist 끝 ====");        //트랜잭션이 commit되기전에 쿼리를 미리보고싶으니까 강제로 flush 해봄        em.flush();        System.out.println("==== flush 끝 ====");    }}